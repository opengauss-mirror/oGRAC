

SQL> alter system set use_bison_parser = true;

Succeed.

SQL> 
SQL> drop table if exists bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b char(10));

Succeed.

SQL> insert into bison_t1 values (1,'abc');

1 rows affected.

SQL> insert into bison_t1 values (1,'abc'), (2, 'abc');

2 rows affected.

SQL> insert into sys.bison_t1 values (1,'abc'), (2, 'abc');

2 rows affected.

SQL> insert sys.bison_t1 values (1,'abc'), (2, 'abc');

2 rows affected.

SQL> insert into bison_t1(a,b) values (1,'abc'), (2, 'abc');

2 rows affected.

SQL> insert into bison_t1(sys.bison_t1.a, bison_t1.b) values (1,'abc'), (2, 'abc');

2 rows affected.

SQL> insert into bison_t1 tbison_t1(sys.bison_t1.a, tbison_t1.b) values (1,'abc'), (2, 'abc');

2 rows affected.

SQL> insert into bison_t1 as values(sys.bison_t1.a, bison_t1.b) values (1,'abc'), (2, 'abc');

OG-00601, [1:25]Sql syntax error: syntax error
SQL> insert into bison_t1 values(sys.bison_t1.a, bison_t1.b) values (1,'abc'), (2, 'abc'); --error

OG-00601, [1:57]Sql syntax error: syntax error
SQL> insert into bison_t1(sys.bison_t1.a, bison_t2.b) values (1,'abc'), (2, 'abc'); --error

OG-00601, [1:78]Sql syntax error: invalid column name
SQL> 
SQL> drop table bison_t2;

OG-00843, [1:20]The table or view SYS.BISON_T2 does not exist.
SQL> create table bison_t2 (a int primary key, b int);

Succeed.

SQL> insert into bison_t2 values (1,1);

1 rows affected.

SQL> insert ignore into bison_t2 values (1,1);

0 rows affected.

SQL> insert into bison_t2 values (1,1); --error

OG-00729, Unique constraint violated, index _PK_SYS_1_48, duplicate key 1
SQL> 
SQL> insert /*+parallel(10)*/ into bison_t2 values (1,1);

OG-00729, Unique constraint violated, index _PK_SYS_1_48, duplicate key 1
SQL> insert /*+parallel(10)*/ into bison_t2(a, b) values (1,1);

OG-00729, Unique constraint violated, index _PK_SYS_1_48, duplicate key 1
SQL> insert /*+opt_param(abc=true)*/ into bison_t2 values (1,1);

OG-00729, Unique constraint violated, index _PK_SYS_1_48, duplicate key 1
SQL> insert /*+db_version(=abc)*/ into bison_t2 values (1,1);

OG-00729, Unique constraint violated, index _PK_SYS_1_48, duplicate key 1
SQL> insert /*+db_version(==abc)*/ into bison_t2 values (1,1);

OG-00729, Unique constraint violated, index _PK_SYS_1_48, duplicate key 1
SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> drop table bison_t2;

Succeed.

SQL> create table bison_t1 (a int);

Succeed.

SQL> create table bison_t2 (a int);

Succeed.

SQL> insert into bison_t2 values (1), (2);

2 rows affected.

SQL> insert all into bison_t1 values (1) into bison_t1 values (2) select a from bison_t2;

4 rows affected.

SQL> insert all into bison_t1 values (1) into bison_t1 values (2) select 1;

2 rows affected.

SQL> insert all into bison_t1 (a) values (1) into bison_t1 (a) values (2) select 1;

2 rows affected.

SQL> insert all into bison_t1 (a) values (1) into bison_t1 values (2) select 1; --error

OG-00601, Sql syntax error: Inconsistent user, table, column or value groups
SQL> 
SQL> insert into bison_t1 select a from bison_t2;

2 rows affected.

SQL> insert into bison_t1(a) select a from bison_t2;

2 rows affected.

SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int primary key, b int);

Succeed.

SQL> insert into bison_t1 values (1,1);

1 rows affected.

SQL> insert into bison_t1 values (1,2) on duplicate key update b = 2;

2 rows affected.

SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int primary key, b int, c int);

Succeed.

SQL> insert into bison_t1 values (1,1,1);

1 rows affected.

SQL> insert into bison_t1 values (1,2,3) on duplicate key update (a, b) = (select 1,2), c = 4;

2 rows affected.

SQL> insert into bison_t1 values (1,2,3) on duplicate key update (a, b) = (1,2), c = 4; --error

OG-00601, [1:71]Sql syntax error: syntax error
SQL> 
SQL> insert into bison_t1 values (1, 1, 1) returning a; --error

OG-00729, Unique constraint violated, index _PK_SYS_1_50, duplicate key 1
SQL> insert into bison_t1 values (1, 1) returning a; --error

OG-00601, Sql syntax error: too less value expressions
SQL> 
SQL> declare
  2 	tmp int;
  3 begin
  4 	insert into bison_t1 values (1,2,3) on duplicate key update (a, b) = (select 1,2), c = 4 returning c into tmp;
  5 	dbe_output.print_line(tmp);
  6 end;
  7 /

OG-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[4:2] PLC-00601 Sql syntax error: unexpected returning columns occurs

SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b int);

Succeed.

SQL> insert into bison_t1 values (1, 1);

1 rows affected.

SQL> insert into bison_t1 values (2, 2);

1 rows affected.

SQL> delete bison_t1;

2 rows affected.

SQL> delete from bison_t1;

0 rows affected.

SQL> 
SQL> insert into bison_t1 values (1, 1);

1 rows affected.

SQL> insert into bison_t1 values (2, 2);

1 rows affected.

SQL> delete from bison_t1 where a;

2 rows affected.

SQL> delete from bison_t1 where (a);

0 rows affected.

SQL> delete from bison_t1 where (a = 2);

0 rows affected.

SQL> 
SQL> delete from bison_t1 where not a;

0 rows affected.

SQL> delete from bison_t1 where not (a = 2);

0 rows affected.

SQL> 
SQL> delete from bison_t1 where a = 1 and b = 2;

0 rows affected.

SQL> 
SQL> insert into bison_t1 values (0, 0), (1, 2);

2 rows affected.

SQL> delete from bison_t1 where a = 0 or b = 2;

2 rows affected.

SQL> 
SQL> insert into bison_t1 values (1,1), (2,2), (3,3);

3 rows affected.

SQL> delete from bison_t1 where a = 2;

1 rows affected.

SQL> delete from bison_t1 where a > 1;

1 rows affected.

SQL> delete from bison_t1 where a < 2;

1 rows affected.

SQL> 
SQL> delete from bison_t1 where a = (select 1);

0 rows affected.

SQL> 
SQL> insert into bison_t1 values (1,1), (2,2), (3,3);

3 rows affected.

SQL> delete from bison_t1 where a >= 2;

2 rows affected.

SQL> delete from bison_t1 where a <= 2;

1 rows affected.

SQL> delete from bison_t1 where a <> 2;

0 rows affected.

SQL> 
SQL> insert into bison_t1 values (1,1), (2,2), (3,3);

3 rows affected.

SQL> delete from bison_t1 where a = any (2,3);

2 rows affected.

SQL> delete from bison_t1 where a = any (select 1);

1 rows affected.

SQL> delete from bison_t1 where a = any ((select 1), (select 3));

0 rows affected.

SQL> delete from bison_t1 where a = any (select 1,2); --error

OG-00687, Values were too many
SQL> 
SQL> delete from bison_t1 where a > any (2, 5);

0 rows affected.

SQL> delete from bison_t1 where a > all (2, 5);

0 rows affected.

SQL> delete from bison_t1 where a < any ((select 1), (select 3));

0 rows affected.

SQL> delete from bison_t1 where a <= any ((select 1), (select 3));

0 rows affected.

SQL> 
SQL> delete from bison_t1 where a in (2, 3);

0 rows affected.

SQL> delete from bison_t1 where a in (select 1);

0 rows affected.

SQL> delete from bison_t1 where a in ((select 1), (select 2));

0 rows affected.

SQL> 
SQL> delete from bison_t1 where a not in (2, 3);

0 rows affected.

SQL> delete from bison_t1 where a not in ((select 1), (select 2));

0 rows affected.

SQL> delete from bison_t1 where (a, b) not in (select 1,1);

0 rows affected.

SQL> 
SQL> delete from bison_t1 where (a, b) in (select 1,1);

0 rows affected.

SQL> delete from bison_t1 where (a,b) in (((select 2), 2));

0 rows affected.

SQL> delete from bison_t1 where (a,b) in (((select 2), 2),(3, (select 3)));

0 rows affected.

SQL> delete from bison_t1 where (a, b) in ((2,3));

0 rows affected.

SQL> delete from bison_t1 where (a,b) in (((select 2), (select 3)), (1,1));

0 rows affected.

SQL> 
SQL> delete from bison_t1 where (a, b) in ((2), (3)); --error

OG-00601, [1:47]Sql syntax error: not enough values
SQL> delete from bison_t1 where (a, b) in (2,3); --error

OG-00601, [1:39]Sql syntax error: syntax error
SQL> delete from bison_t1 where (a, b) in (select 2); --error

OG-00923, Values were not enough
SQL> delete from bison_t1 where (a,b) in (((select 1), 2), ((select 2))); --error

OG-00601, [1:67]Sql syntax error: not enough values
SQL> 
SQL> insert into bison_t1 values (null, 2);

1 rows affected.

SQL> delete from bison_t1 where a is null;

1 rows affected.

SQL> delete from bison_t1 where (select 1) is null;

0 rows affected.

SQL> delete from bison_t1 where a is not null;

0 rows affected.

SQL> 
SQL> delete from bison_t1 where a is not json;

0 rows affected.

SQL> delete from bison_t1 where a is json;

0 rows affected.

SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a varchar(10));

Succeed.

SQL> insert into bison_t1 values ('abcdef');

1 rows affected.

SQL> insert into bison_t1 values ('abcdef%');

1 rows affected.

SQL> delete from bison_t1 where a like 'abc%';

2 rows affected.

SQL> delete from bison_t1 where a not like 'abc%';

0 rows affected.

SQL> 
SQL> delete from bison_t1 where (select 'abc') like 'abc%';

0 rows affected.

SQL> 
SQL> delete from bison_t1 where a like '%\%' escape '\';

0 rows affected.

SQL> delete from bison_t1 where a not like '%\%' escape '\';

0 rows affected.

SQL> 
SQL> delete from bison_t1 where a regexp 'abc';

0 rows affected.

SQL> delete from bison_t1 where a not regexp 'abc';

0 rows affected.

SQL> 
SQL> delete from bison_t1 where a between 'ab' and 'ac';

0 rows affected.

SQL> delete from bison_t1 where a not between 'ab' and 'ac';

0 rows affected.

SQL> 
SQL> alter system set _OPTIM_SUBQUERY_REWRITE=false;

Succeed.

SQL> delete from bison_t1 where exists (select 'ab');

0 rows affected.

SQL> delete from bison_t1 where not exists (select 'ab');

0 rows affected.

SQL> 
SQL> delete from bison_t1 where regexp_like (a, 'ab');

0 rows affected.

SQL> delete from bison_t1 where regexp_like (a);  --error

OG-00615, Invalid argument number for REGEXP_LIKE, min=2, max=3
SQL> delete from bison_t1 where regexp_like (a, 'ab', 'ab', 'ab');  --error

OG-00615, Invalid argument number for REGEXP_LIKE, min=2, max=3
SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b int);

Succeed.

SQL> insert into bison_t1 values (1, 1);

1 rows affected.

SQL> insert into bison_t1 values (2, 2);

1 rows affected.

SQL> 
SQL> drop table bison_t2;

Succeed.

SQL> create table bison_t2 (c int, d int);

Succeed.

SQL> insert into bison_t2 values (1, 1);

1 rows affected.

SQL> insert into bison_t2 values (2, 2);

1 rows affected.

SQL> 
SQL> delete from bison_t1 where a = 1;

1 rows affected.

SQL> delete from bison_t1 using bison_t1, bison_t2 where a = 1;	

0 rows affected.

SQL> delete from bison_t1, bison_t2 using bison_t1, bison_t2 where a = 2;

3 rows affected.

SQL> 
SQL> delete from bison_t1 using bison_t1, bison_t2;

0 rows affected.

SQL> 
SQL> delete from bison_t1 using bison_t2 partition(p1), bison_t1 where a = 1;

OG-00601, Sql syntax error: BISON_T2 is not a partition table
SQL> 
SQL> delete from bison_t1, bison_t2 using bison_t1 join bison_t2 where a = c;

OG-00601, [1:52]Sql syntax error: syntax error
SQL> 
SQL> delete from bison_t1, bison_t2 using bison_t1 inner join bison_t2 where a = c;

OG-00601, Sql syntax error: unknown table BISON_T1 in multi delete
SQL> 
SQL> delete from bison_t1, bison_t2 using bison_t1 join bison_t2 on a = c;

OG-00601, [1:52]Sql syntax error: syntax error
SQL> 
SQL> delete from bison_t1, bison_t2; -- error

OG-00601, [1:31]Sql syntax error: USING expected
SQL> 
SQL> delete bison_t1 from bison_t1, bison_t2 where a = 1;

0 rows affected.

SQL> delete bison_t1, bison_t2 from bison_t1, bison_t2 where a = 2;

0 rows affected.

SQL> 
SQL> delete bison_t1, bison_t2; -- error

OG-00601, [1:26]Sql syntax error: FROM expected
SQL> 
SQL> select 1 from table(abc(1,2));  --does not exist

OG-00845, Function ABC does not exist in oGRAC
SQL> select 1 from table(cast(1 as int)); -- verify error

OG-00606, Inconsistent datatypes, expected PLSQL INDEX TABLE - got BINARY_INTEGER
SQL> 
SQL> select name from json_table('{"name":"Messi", "age": 10}' format json, '$' default '1' on error COLUMNS(name (RETURNING varchar2) PATH '$.name', age varchar2 PATH '$.age')); --error

OG-00601, [1:110]Sql syntax error: syntax error
SQL> 
SQL> select name from json_table('{"name":"Messi", "age": 10}' format json, '$' default '1' on error COLUMNS(name for ordinality, age varchar2 PATH '$.age'));

NAME                
--------------------
1                   

1 rows fetched.

SQL> 
SQL> select name from json_table('{"name":"Messi", "age": 10}' format json, '$' default '1' on error COLUMNS(name for ordinality, age varchar2('10abc') PATH '$.age')); --error

OG-00601, [1:139]Sql syntax error: syntax error
SQL> 
SQL> select name from json_table('{"name":"Messi", "age": 10}' format json, '$' default '1' on error COLUMNS(name varchar2 exists PATH '$.name' TRUE ON ERROR, age varchar2 exists PATH '$.age' TRUE ON ERROR));

NAME                                                            
----------------------------------------------------------------
TRUE                                                            

1 rows fetched.

SQL> 
SQL> select name from json_table('{"name":"Messi", "age": 10}' format json, '$' default '1' on error COLUMNS(name varchar2 PATH '$.name' TRUE ON ERROR, age varchar2 PATH '$.age' TRUE ON ERROR));  -- error

OG-02501, [1:105]Invalid RETURNING/ON ERROR/ON EMPTY clause, 
SQL> 
SQL> select name from json_table('{"name":"Messi", "age": 10}' format json, '$' default '1' on error COLUMNS(name for ordinality, age varchar2(10) PATH '$.age')) jian;

NAME                
--------------------
1                   

1 rows fetched.

SQL> 
SQL> select name from json_table('{"name":"Messi"}' format json, '$' default '1' on error COLUMNS(name for ordinality));

NAME                
--------------------
1                   

1 rows fetched.

SQL> 
SQL> select name from json_table('{"name":"Messi"}' format json, '$' default '1' on error COLUMNS(name varchar2(10) PATH '$.age'));

NAME                                                        
------------------------------------------------------------
1                                                           

1 rows fetched.

SQL> 
SQL> select name from json_table('{"name":"Messi", "age": 10}' format json, '$' default '1' on error COLUMNS(name varchar2 exists PATH '$.name' TRUE ON ERROR, age varchar2 exists PATH '$.age' TRUE ON ERROR));

NAME                                                            
----------------------------------------------------------------
TRUE                                                            

1 rows fetched.

SQL> 
SQL> 
SQL> 
SQL> create table clob_bison_t1 (a clob);

Succeed.

SQL> insert into clob_bison_t1 values ('{"name":"Messi", "age": 10}');

1 rows affected.

SQL> select * from clob_bison_t1, json_table (clob_bison_t1.a, '$' default '1' on error COLUMNS(name varchar2 PATH '$.name', age varchar2 PATH '$.age'));

A                                                                NAME                                                             AGE                                                             
---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
{"name":"Messi", "age": 10}                                      Messi                                                            10                                                              

1 rows fetched.

SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b int);

Succeed.

SQL> insert into bison_t1 values (1,1), (2,2);

2 rows affected.

SQL> delete from bison_t1 limit 1 offset 1;

1 rows affected.

SQL> 
SQL> delete from bison_t1 order by a desc limit 1 offset 1;

0 rows affected.

SQL> delete from bison_t1 order by a desc limit 1 offset 1 returning a;

A           
------------

0 rows fetched.

SQL> 
SQL> delete from bison_t1 order by a desc offset 1 limit 1;

0 rows affected.

SQL> 
SQL> delete from bison_t1 order siblings by a desc limit 1 offset 1; --error

OG-00601, [1:28]Sql syntax error: syntax error
SQL> delete from bison_t1, bison_t2 using bison_t1, bison_t2 limit 1 offset 1;  --error

OG-00601, [1:73]Sql syntax error: multi delete do not support limit
SQL> delete from bison_t1, bison_t2 using bison_t1, bison_t2 order by a;  --error

OG-00601, [1:67]Sql syntax error: multi delete do not support order by
SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b int);

Succeed.

SQL> insert into bison_t1 values (1,1), (2,2);

2 rows affected.

SQL> update bison_t1 set a = 1 where b = 2;

1 rows affected.

SQL> update bison_t1 set a = 3, b = 3 where a = 1;

2 rows affected.

SQL> 
SQL> drop table bison_t2;

Succeed.

SQL> create table bison_t2 (c int, d int);

Succeed.

SQL> insert into bison_t2 values (1,1), (2,2);

2 rows affected.

SQL> update bison_t1, bison_t2 set a = 3, b = 3 where a = 1;

0 rows affected.

SQL> 
SQL> select a from bison_t1;

A           
------------
3           
3           

2 rows fetched.

SQL> select abs
  2 (a) from bison_t1;

ABS
(A)                                 
----------------------------------------
3                                       
3                                       

2 rows fetched.

SQL> select 1;

1           
------------
1           

1 rows fetched.

SQL> 
SQL> select a as "abc" from bison_t1;

abc         
------------
3           
3           

2 rows fetched.

SQL> select a as abc from bison_t1;

ABC         
------------
3           
3           

2 rows fetched.

SQL> select a "abc" from bison_t1;

abc         
------------
3           
3           

2 rows fetched.

SQL> select a abc from bison_t1;

ABC         
------------
3           
3           

2 rows fetched.

SQL> 
SQL> select "A" from bison_t1;

A           
------------
3           
3           

2 rows fetched.

SQL> select "a" from bison_t1;

OG-00601, [1:8]Sql syntax error: invalid column name 'a'
SQL> select a from bison_t1;

A           
------------
3           
3           

2 rows fetched.

SQL> 
SQL> select a "abc", b def from bison_t1;

abc          DEF         
------------ ------------
3            3           
3            3           

2 rows fetched.

SQL> 
SQL> select * from bison_t1, bison_t2;

A            B            C            D           
------------ ------------ ------------ ------------
3            3            1            1           
3            3            2            2           
3            3            1            1           
3            3            2            2           

4 rows fetched.

SQL> 
SQL> -- 创建销售数据表
SQL> CREATE TABLE sales_data (
  2     product_id VARCHAR2(10),
  3     month VARCHAR2(20),
  4     sales_amount NUMBER(10,2),
  5     region VARCHAR2(20)
  6 );

Succeed.

SQL> 
SQL> -- 插入示例数据
SQL> INSERT INTO sales_data VALUES ('P001', 'January', 1000, 'North');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P001', 'February', 1500, 'North');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P001', 'March', 1200, 'North');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P001', 'January', 800, 'South');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P001', 'February', 900, 'South');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P001', 'March', 1100, 'South');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P002', 'January', 2000, 'North');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P002', 'February', 1800, 'North');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P002', 'March', 2200, 'North');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P002', 'January', 1200, 'South');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P002', 'February', 1400, 'South');

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('P002', 'March', 1600, 'South');

1 rows affected.

SQL> 
SQL> COMMIT;

Succeed.

SQL> 
SQL> -- 简单的按月汇总
SQL> SELECT *
  2 FROM (
  3     SELECT product_id, month, sales_amount
  4     FROM sales_data
  5 )
  6 PIVOT (
  7     SUM(sales_amount)
  8     FOR month IN ('January' AS Jan, 'February' AS Feb, 'March' AS Mar)
  9 )
 10 ORDER BY product_id;

PRODUCT_ID JAN                                      FEB                                      MAR                                     
---------- ---------------------------------------- ---------------------------------------- ----------------------------------------
P001       1800                                     2400                                     2300                                    
P002       3200                                     3200                                     3800                                    

2 rows fetched.

SQL> 
SQL> 
SQL> SELECT *
  2 FROM (
  3     SELECT product_id, month, sales_amount
  4     FROM sales_data
  5 )
  6 PIVOT (
  7     SUM(sales_amount)
  8     FOR month IN ('January' AS Jan, 'February' AS Feb, 'March' AS Mar)
  9 )
 10 PIVOT (
 11     SUM(jan)
 12     FOR product_id IN ('P001' AS p1, 'P002' AS p2)
 13 );

FEB                                      MAR                                      P1                                       P2                                      
---------------------------------------- ---------------------------------------- ---------------------------------------- ----------------------------------------
3200                                     3800                                                                              3200                                    
2400                                     2300                                     1800                                                                             

2 rows fetched.

SQL> 
SQL> SELECT *
  2 FROM (
  3     SELECT product_id, month, sales_amount
  4     FROM sales_data
  5 )
  6 PIVOT (
  7     sales_amount
  8     FOR month IN ('January' AS Jan, 'February' AS Feb, 'March' AS Mar)
  9 )
 10 ORDER BY product_id; -- verify error

OG-00612, Aggregation function expected, but SALES_AMOUNT found
SQL> 
SQL> SELECT *
  2 FROM (
  3     SELECT product_id, month, sales_amount
  4     FROM sales_data
  5 )
  6 PIVOT (
  7     SUM(sales_amount)
  8     FOR month IN ('January', 'February', 'March')
  9 )
 10 ORDER BY product_id;

PRODUCT_ID 'JANUARY'                                'FEBRUARY'                               'MARCH'                                 
---------- ---------------------------------------- ---------------------------------------- ----------------------------------------
P001       1800                                     2400                                     2300                                    
P002       3200                                     3200                                     3800                                    

2 rows fetched.

SQL> 
SQL> SELECT *
  2 FROM (
  3     SELECT product_id, month, sales_amount
  4     FROM sales_data
  5 )
  6 PIVOT (
  7     SUM(sales_amount)
  8     FOR (product_id, month) IN (('P001', 'January'), ('P001', 'February'), ('P001', 'March'), ('P002', 'January'), ('P002', 'February'), ('P002', 'March'))
  9 );

'P001'_'January'                         'P001'_'February'                        'P001'_'March'                           'P002'_'January'                         'P002'_'February'                        'P002'_'March'                          
---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ----------------------------------------
1800                                     2400                                     2300                                     3200                                     3200                                     3800                                    

1 rows fetched.

SQL> 
SQL> drop table sales_data;

Succeed.

SQL> CREATE TABLE sales_data (
  2     region VARCHAR2(20),
  3     quarter VARCHAR2(10),
  4     product_a NUMBER,
  5     product_b NUMBER,
  6     product_c NUMBER
  7 );

Succeed.

SQL> 
SQL> INSERT INTO sales_data VALUES ('North', 'Q1', 1000, 1500, 1200);

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('North', 'Q2', 1100, 1600, 1300);

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('South', 'Q1', 900, 1400, 1100);

1 rows affected.

SQL> INSERT INTO sales_data VALUES ('South', 'Q2', 950, 1450, 1150);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT region, quarter, product_type, sales_amount
  2 FROM sales_data
  3 UNPIVOT (
  4     sales_amount          -- 新列：存放原来多列的值
  5     FOR product_type      -- 新列：存放原来列名的描述
  6     IN (                  -- 指定要转换的列
  7         product_a AS 'A', -- 可以给原列名起别名
  8         product_b AS 'B',
  9         product_c AS 'C'
 10     )
 11 );

REGION               QUARTER    PRODUCT_TYPE SALES_AMOUNT                            
-------------------- ---------- ------------ ----------------------------------------
North                Q1         A            1000                                    
North                Q1         B            1500                                    
North                Q1         C            1200                                    
North                Q2         A            1100                                    
North                Q2         B            1600                                    
North                Q2         C            1300                                    
South                Q1         A            900                                     
South                Q1         B            1400                                    
South                Q1         C            1100                                    
South                Q2         A            950                                     
South                Q2         B            1450                                    
South                Q2         C            1150                                    

12 rows fetched.

SQL> 
SQL> -- 包含NULL值的数据
SQL> INSERT INTO sales_data VALUES ('West', 'Q1', NULL, 1800, 1400);

1 rows affected.

SQL> 
SQL> -- 使用INCLUDE NULLS（默认是EXCLUDE NULLS）
SQL> SELECT region, quarter, product_type, sales_amount
  2 FROM sales_data
  3 UNPIVOT INCLUDE NULLS (
  4     sales_amount
  5     FOR product_type
  6     IN (
  7         product_a AS 'A',
  8         product_b AS 'B',
  9         product_c AS 'C'
 10     )
 11 );

REGION               QUARTER    PRODUCT_TYPE SALES_AMOUNT                            
-------------------- ---------- ------------ ----------------------------------------
North                Q1         A            1000                                    
North                Q1         B            1500                                    
North                Q1         C            1200                                    
North                Q2         A            1100                                    
North                Q2         B            1600                                    
North                Q2         C            1300                                    
South                Q1         A            900                                     
South                Q1         B            1400                                    
South                Q1         C            1100                                    
South                Q2         A            950                                     
South                Q2         B            1450                                    
South                Q2         C            1150                                    
West                 Q1         A                                                    
West                 Q1         B            1800                                    
West                 Q1         C            1400                                    

15 rows fetched.

SQL> 
SQL> SELECT region, quarter, product_type, sales_amount
  2 FROM sales_data
  3 UNPIVOT EXCLUDE NULLS (
  4     sales_amount
  5     FOR product_type
  6     IN (
  7         product_a AS 'A',
  8         product_b AS 'B',
  9         product_c AS 'C'
 10     )
 11 );

REGION               QUARTER    PRODUCT_TYPE SALES_AMOUNT                            
-------------------- ---------- ------------ ----------------------------------------
North                Q1         A            1000                                    
North                Q1         B            1500                                    
North                Q1         C            1200                                    
North                Q2         A            1100                                    
North                Q2         B            1600                                    
North                Q2         C            1300                                    
South                Q1         A            900                                     
South                Q1         B            1400                                    
South                Q1         C            1100                                    
South                Q2         A            950                                     
South                Q2         B            1450                                    
South                Q2         C            1150                                    
West                 Q1         B            1800                                    
West                 Q1         C            1400                                    

14 rows fetched.

SQL> 
SQL> CREATE TABLE employee_metrics (
  2     emp_id NUMBER,
  3     emp_name VARCHAR2(50),
  4     q1_sales NUMBER,
  5     q1_target NUMBER,
  6     q2_sales NUMBER,
  7     q2_target NUMBER
  8 );

Succeed.

SQL> 
SQL> INSERT INTO employee_metrics VALUES (1, '张三', 50000, 45000, 55000, 50000);

1 rows affected.

SQL> INSERT INTO employee_metrics VALUES (2, '李四', 48000, 50000, 52000, 48000);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT emp_id, emp_name, quarter, sales, target
  2 FROM employee_metrics
  3 UNPIVOT (
  4     (sales, target)           -- 同时处理多列值对
  5     FOR quarter
  6     IN (
  7         (q1_sales, q1_target) AS 'Q1',
  8         (q2_sales, q2_target) AS 'Q2'
  9     )
 10 );

EMP_ID                                   EMP_NAME                                           QUARTER SALES                                    TARGET                                  
---------------------------------------- -------------------------------------------------- ------- ---------------------------------------- ----------------------------------------
1                                        张三                                             Q1      50000                                    45000                                   
1                                        张三                                             Q2      55000                                    50000                                   
2                                        李四                                             Q1      48000                                    50000                                   
2                                        李四                                             Q2      52000                                    48000                                   

4 rows fetched.

SQL> 
SQL> -- 创建员工表
SQL> CREATE TABLE employees (
  2     employee_id NUMBER,
  3     employee_name VARCHAR2(50),
  4     manager_id NUMBER
  5 );

Succeed.

SQL> 
SQL> -- 插入测试数据
SQL> INSERT INTO employees VALUES (1, 'CEO', NULL);

1 rows affected.

SQL> INSERT INTO employees VALUES (2, '技术副总裁', 1);

1 rows affected.

SQL> INSERT INTO employees VALUES (3, '销售副总裁', 1);

1 rows affected.

SQL> INSERT INTO employees VALUES (4, '开发经理', 2);

1 rows affected.

SQL> INSERT INTO employees VALUES (5, '测试经理', 2);

1 rows affected.

SQL> INSERT INTO employees VALUES (6, '销售经理', 3);

1 rows affected.

SQL> INSERT INTO employees VALUES (7, '高级开发工程师', 4);

1 rows affected.

SQL> INSERT INTO employees VALUES (8, '初级开发工程师', 4);

1 rows affected.

SQL> INSERT INTO employees VALUES (9, '测试工程师', 5);

1 rows affected.

SQL> INSERT INTO employees VALUES (10, '销售代表', 6);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT 
  2     employee_id,
  3     employee_name,
  4     manager_id
  5 FROM employees
  6 START WITH manager_id IS NULL
  7 CONNECT BY PRIOR employee_id = manager_id;

EMPLOYEE_ID                              EMPLOYEE_NAME                                      MANAGER_ID                              
---------------------------------------- -------------------------------------------------- ----------------------------------------
1                                        CEO                                                                                        
2                                        技术副总裁                                    1                                       
4                                        开发经理                                       2                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
5                                        测试经理                                       2                                       
9                                        测试工程师                                    5                                       
3                                        销售副总裁                                    1                                       
6                                        销售经理                                       3                                       
10                                       销售代表                                       6                                       

10 rows fetched.

SQL> 
SQL> SELECT 
  2     employee_id,
  3     employee_name,
  4     manager_id
  5 FROM employees
  6 START WITH manager_id IS NULL
  7 CONNECT BY PRIOR employee_id = manager_id order siblings by employee_id;

EMPLOYEE_ID                              EMPLOYEE_NAME                                      MANAGER_ID                              
---------------------------------------- -------------------------------------------------- ----------------------------------------
1                                        CEO                                                                                        
2                                        技术副总裁                                    1                                       
4                                        开发经理                                       2                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
5                                        测试经理                                       2                                       
9                                        测试工程师                                    5                                       
3                                        销售副总裁                                    1                                       
6                                        销售经理                                       3                                       
10                                       销售代表                                       6                                       

10 rows fetched.

SQL> 
SQL> -- 原生会报错,order by前加个括号就可以执行；raw_parser加不加都可以执行，结果一致
SQL> SELECT 
  2     employee_id,
  3     employee_name,
  4     manager_id
  5 FROM employees
  6 START WITH manager_id IS NULL
  7 CONNECT BY PRIOR employee_id = manager_id order siblings by employee_id order by manager_id;

EMPLOYEE_ID                              EMPLOYEE_NAME                                      MANAGER_ID                              
---------------------------------------- -------------------------------------------------- ----------------------------------------
1                                        CEO                                                                                        
2                                        技术副总裁                                    1                                       
4                                        开发经理                                       2                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
5                                        测试经理                                       2                                       
9                                        测试工程师                                    5                                       
3                                        销售副总裁                                    1                                       
6                                        销售经理                                       3                                       
10                                       销售代表                                       6                                       

10 rows fetched.

SQL> 
SQL> -- error
SQL> (SELECT 
  2     employee_id,
  3     employee_name,
  4     manager_id
  5 FROM employees
  6 START WITH manager_id IS NULL
  7 CONNECT BY PRIOR employee_id = manager_id) order siblings by employee_id;

OG-00601, [7:50]Sql syntax error: syntax error
SQL> 
SQL> select * from bison_t1 order siblings by a; -- error

OG-00601, [1:43]Sql syntax error: ORDER SIBLINGS BY clause not allowed here.
SQL> 
SQL> SELECT 
  2     employee_id,
  3     employee_name,
  4     manager_id
  5 FROM employees
  6 CONNECT BY PRIOR employee_id = manager_id
  7 START WITH manager_id IS NULL;

EMPLOYEE_ID                              EMPLOYEE_NAME                                      MANAGER_ID                              
---------------------------------------- -------------------------------------------------- ----------------------------------------
1                                        CEO                                                                                        
2                                        技术副总裁                                    1                                       
4                                        开发经理                                       2                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
5                                        测试经理                                       2                                       
9                                        测试工程师                                    5                                       
3                                        销售副总裁                                    1                                       
6                                        销售经理                                       3                                       
10                                       销售代表                                       6                                       

10 rows fetched.

SQL> 
SQL> SELECT 
  2     employee_id,
  3     employee_name,
  4     manager_id
  5 FROM employees
  6 CONNECT BY PRIOR employee_id = manager_id;

EMPLOYEE_ID                              EMPLOYEE_NAME                                      MANAGER_ID                              
---------------------------------------- -------------------------------------------------- ----------------------------------------
1                                        CEO                                                                                        
2                                        技术副总裁                                    1                                       
4                                        开发经理                                       2                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
5                                        测试经理                                       2                                       
9                                        测试工程师                                    5                                       
3                                        销售副总裁                                    1                                       
6                                        销售经理                                       3                                       
10                                       销售代表                                       6                                       
2                                        技术副总裁                                    1                                       
4                                        开发经理                                       2                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
5                                        测试经理                                       2                                       
9                                        测试工程师                                    5                                       
3                                        销售副总裁                                    1                                       
6                                        销售经理                                       3                                       
10                                       销售代表                                       6                                       
4                                        开发经理                                       2                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
5                                        测试经理                                       2                                       
9                                        测试工程师                                    5                                       
6                                        销售经理                                       3                                       
10                                       销售代表                                       6                                       
7                                        高级开发工程师                              4                                       
8                                        初级开发工程师                              4                                       
9                                        测试工程师                                    5                                       
10                                       销售代表                                       6                                       

30 rows fetched.

SQL> 
SQL> -- 目前会报错，level需要映射为EXPR_NODE_RESERVED
SQL> SELECT 
  2     employee_id,
  3     employee_name,
  4     manager_id,
  5     level as hierarchy_level
  6 FROM employees
  7 START WITH manager_id IS NULL
  8 CONNECT BY PRIOR employee_id = manager_id;

EMPLOYEE_ID                              EMPLOYEE_NAME                                      MANAGER_ID                               HIERARCHY_LEVEL
---------------------------------------- -------------------------------------------------- ---------------------------------------- ---------------
1                                        CEO                                                                                         1              
2                                        技术副总裁                                    1                                        2              
4                                        开发经理                                       2                                        3              
7                                        高级开发工程师                              4                                        4              
8                                        初级开发工程师                              4                                        4              
5                                        测试经理                                       2                                        3              
9                                        测试工程师                                    5                                        4              
3                                        销售副总裁                                    1                                        2              
6                                        销售经理                                       3                                        3              
10                                       销售代表                                       6                                        4              

10 rows fetched.

SQL> 
SQL> -- 创建示例表
SQL> drop table sales_data;

Succeed.

SQL> CREATE TABLE sales_data (
  2     sale_id NUMBER,
  3     region VARCHAR2(20),
  4     product_category VARCHAR2(20),
  5     salesperson VARCHAR2(30),
  6     sale_amount NUMBER(10,2),
  7     sale_date DATE
  8 );

Succeed.

SQL> 
SQL> -- 插入示例数据
SQL> INSERT INTO sales_data VALUES (1, 'North', 'Electronics', 'John', 1500, DATE '2024-01-15');

OG-00601, [1:78]Sql syntax error: syntax error
SQL> INSERT INTO sales_data VALUES (2, 'North', 'Furniture', 'John', 2500, DATE '2024-01-20');

OG-00601, [1:76]Sql syntax error: syntax error
SQL> INSERT INTO sales_data VALUES (3, 'South', 'Electronics', 'Sarah', 1800, DATE '2024-01-10');

OG-00601, [1:79]Sql syntax error: syntax error
SQL> INSERT INTO sales_data VALUES (4, 'South', 'Furniture', 'Sarah', 2200, DATE '2024-01-25');

OG-00601, [1:77]Sql syntax error: syntax error
SQL> INSERT INTO sales_data VALUES (5, 'North', 'Electronics', 'Mike', 1200, DATE '2024-02-05');

OG-00601, [1:78]Sql syntax error: syntax error
SQL> INSERT INTO sales_data VALUES (6, 'South', 'Furniture', 'Mike', 1900, DATE '2024-02-10');

OG-00601, [1:76]Sql syntax error: syntax error
SQL> INSERT INTO sales_data VALUES (7, 'North', 'Electronics', 'John', 1700, DATE '2024-02-15');

OG-00601, [1:78]Sql syntax error: syntax error
SQL> INSERT INTO sales_data VALUES (8, 'South', 'Electronics', 'Sarah', 2100, DATE '2024-02-20');

OG-00601, [1:79]Sql syntax error: syntax error
SQL> 
SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT 
  2     region,
  3     product_category,
  4     SUM(sale_amount) AS total_sales
  5 FROM sales_data
  6 GROUP BY GROUPING SETS ( 
  7     (region, product_category));

REGION               PRODUCT_CATEGORY     TOTAL_SALES                             
-------------------- -------------------- ----------------------------------------

0 rows fetched.

SQL> 
SQL> SELECT 
  2     region,
  3     product_category,
  4     SUM(sale_amount) AS total_sales
  5 FROM sales_data
  6 GROUP BY ( 
  7     region, product_category);

REGION               PRODUCT_CATEGORY     TOTAL_SALES                             
-------------------- -------------------- ----------------------------------------

0 rows fetched.

SQL> 
SQL> SELECT 
  2     region,
  3     product_category,
  4     SUM(sale_amount) AS total_sales
  5 FROM sales_data
  6 GROUP BY GROUPING SETS ( grouping sets
  7     (region, product_category));

OG-00601, [6:35]Sql syntax error: syntax error
SQL> 
SQL> 
SQL> SELECT 
  2     region,
  3     product_category,
  4     salesperson,
  5     SUM(sale_amount) AS total_sales,
  6     COUNT(*) AS transaction_count
  7 FROM sales_data
  8 GROUP BY GROUPING SETS (
  9     (region, product_category, salesperson),
 10     (region, product_category),             
 11     (region, salesperson),                  
 12     (product_category, salesperson),        
 13     (region),                               
 14     (product_category),                     
 15     (salesperson),                           
 16     ()
 17 );

REGION               PRODUCT_CATEGORY     SALESPERSON                    TOTAL_SALES                              TRANSACTION_COUNT   
-------------------- -------------------- ------------------------------ ---------------------------------------- --------------------

0 rows fetched.

SQL> 
SQL> SELECT 
  2     region,
  3     product_category,
  4     salesperson,
  5     SUM(sale_amount) AS total_sales,
  6     GROUPING_ID(region, product_category, salesperson) AS grp_id
  7 FROM sales_data
  8 GROUP BY GROUPING SETS (
  9     ROLLUP(region, product_category, salesperson)
 10 );

REGION               PRODUCT_CATEGORY     SALESPERSON                    TOTAL_SALES                              GRP_ID              
-------------------- -------------------- ------------------------------ ---------------------------------------- --------------------

0 rows fetched.

SQL> 
SQL> SELECT 
  2     region,
  3     product_category,
  4     salesperson,
  5     SUM(sale_amount) AS total_sales,
  6     GROUPING_ID(region, product_category, salesperson) AS grp_id
  7 FROM sales_data
  8 GROUP BY CUBE (region, product_category, salesperson);

REGION               PRODUCT_CATEGORY     SALESPERSON                    TOTAL_SALES                              GRP_ID              
-------------------- -------------------- ------------------------------ ---------------------------------------- --------------------

0 rows fetched.

SQL> 
SQL> SELECT salesperson, SUM(sale_amount) AS total_sales
  2 FROM sales_data
  3 GROUP BY salesperson
  4 HAVING SUM(sale_amount) > 5000;

SALESPERSON                    TOTAL_SALES                             
------------------------------ ----------------------------------------

0 rows fetched.

SQL> 
SQL> SELECT region, 
  2        SUM(sale_amount) AS total_sales,
  3        AVG(sale_amount) AS avg_sale
  4 FROM sales_data
  5 GROUP BY region
  6 HAVING SUM(sale_amount) > 3000 
  7    AND AVG(sale_amount) < 2000;

REGION               TOTAL_SALES                              AVG_SALE                                
-------------------- ---------------------------------------- ----------------------------------------

0 rows fetched.

SQL> 
SQL> SELECT region, product_category, COUNT(*) AS order_count
  2 FROM sales_data
  3 WHERE sale_date >= '2024-01-01'
  4 GROUP BY region, product_category
  5 HAVING COUNT(*) >= 2;

REGION               PRODUCT_CATEGORY     ORDER_COUNT         
-------------------- -------------------- --------------------

0 rows fetched.

SQL> 
SQL> SELECT salesperson, COUNT(DISTINCT product_category) AS category_count
  2 FROM sales_data
  3 GROUP BY salesperson
  4 HAVING COUNT(DISTINCT product_category) >= 2;

SALESPERSON                    CATEGORY_COUNT      
------------------------------ --------------------

0 rows fetched.

SQL> 
SQL> SELECT region, product_category, SUM(sale_amount) AS total
  2 FROM sales_data
  3 GROUP BY GROUPING SETS ((region), (product_category), ())
  4 HAVING SUM(sale_amount) > 4000;

REGION               PRODUCT_CATEGORY     TOTAL                                   
-------------------- -------------------- ----------------------------------------

0 rows fetched.

SQL> 
SQL> drop table if exists bison_t1;

Succeed.

SQL> create table bison_t1 (a int);

Succeed.

SQL> insert into bison_t1 values (2), (1), (3), (5);

4 rows affected.

SQL> insert into bison_t1 values (null);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select * from bison_t1 order by a;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> select * from bison_t1 order by a asc;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> select * from bison_t1 order by a desc;

A           
------------
            
5           
3           
2           
1           

5 rows fetched.

SQL> select * from bison_t1 order by a nulls first;

A           
------------
            
1           
2           
3           
5           

5 rows fetched.

SQL> select * from bison_t1 order by a nulls last;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> 
SQL> select * from bison_t1 order by a desc limit 2 offset 1;

A           
------------
5           
3           

2 rows fetched.

SQL> select * from bison_t1 order by a desc offset 2 limit 1;

A           
------------
3           

1 rows fetched.

SQL> 
SQL> select a from bison_t1 union select c from bison_t2;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> select a from bison_t1 union all select c from bison_t2;

A           
------------
2           
1           
3           
5           
            
1           
2           

7 rows fetched.

SQL> select a from bison_t1 intersect select c from bison_t2;

A           
------------
1           
2           

2 rows fetched.

SQL> select a from bison_t1 intersect all select c from bison_t2;

A           
------------
1           
2           

2 rows fetched.

SQL> select a from bison_t1 intersect distinct select c from bison_t2;

A           
------------
1           
2           

2 rows fetched.

SQL> select a from bison_t1 except select c from bison_t2;

A           
------------
3           
5           
            

3 rows fetched.

SQL> select a from bison_t1 except all select c from bison_t2;

A           
------------
3           
5           
            

3 rows fetched.

SQL> select a from bison_t1 except distinct select c from bison_t2;

A           
------------
3           
5           
            

3 rows fetched.

SQL> select a from bison_t1 minus select c from bison_t2;

A           
------------
3           
5           
            

3 rows fetched.

SQL> 
SQL> select a from bison_t1 order by a union select c from bison_t2; -- error

OG-00601, [1:35]Sql syntax error: syntax error
SQL> (select a from bison_t1 order by a) union select c from bison_t2;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> (select a from bison_t1 order by a) union (select c from bison_t2 order by c);

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> select a from bison_t1 union select c from bison_t2 order by a;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> 
SQL> select a from bison_t1 limit 1 union select c from bison_t2; -- error

OG-00601, [1:32]Sql syntax error: syntax error
SQL> (select a from bison_t1 limit 1) union select c from bison_t2;

A           
------------
1           
2           

2 rows fetched.

SQL> 
SQL> select * from bison_t1 for update;

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> select * from bison_t1 for update of a;

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> select * from bison_t1 for update of a nowait;

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> select * from bison_t1 for update of a wait 10;

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> select * from bison_t1 for update of a skip locked;

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> select a from bison_t1 union select c from bison_t2 order by a for update;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> select a from bison_t1 for update union select c from bison_t2 order by a;

OG-00601, [1:35]Sql syntax error: syntax error
SQL> 
SQL> 
SQL> select SQL_CALC_FOUND_ROWS * from bison_t1 limit 2;

A           
------------
2           
1           

2 rows fetched.

SQL> select found_rows();

FOUND_ROWS()        
--------------------
5                   

1 rows fetched.

SQL> 
SQL> select SQL_CALC_FOUND_ROWS c from bison_t2 union select a from bison_t1;

C           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> (select SQL_CALC_FOUND_ROWS c from bison_t2) union (select a from bison_t1);

C           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> 
SQL> select a from bison_t1 union select SQL_CALC_FOUND_ROWS c from bison_t2 limit 1;

A           
------------
1           

1 rows fetched.

SQL> (select a from bison_t1) union (select SQL_CALC_FOUND_ROWS c from bison_t2);

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> 
SQL> with tmp as (select c from bison_t2) select * from tmp;

C           
------------
1           
2           

2 rows fetched.

SQL> (select a from bison_t1) union (with tmp as (select c from bison_t2) select * from tmp);

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> 
SQL> with tmp as (select a from bison_t1) select * from (with tmp as (select c from bison_t2) select * from tmp);

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> 
SQL> -- 子查询
SQL> select * from (select a from bison_t1);

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> select * from bison_t1 where a in (select c from bison_t2);

A           
------------
2           
1           

2 rows fetched.

SQL> 
SQL> select * from (with tmp as (select c from bison_t2) select * from tmp), tmp;

C            C           
------------ ------------
1            1           
1            2           
2            1           
2            2           

4 rows fetched.

SQL> 
SQL> with tmp as (with tmp1 as (select * from bison_t1) select * from tmp1) select * from tmp;

A           
------------
2           
1           
3           
5           
            

5 rows fetched.

SQL> 
SQL> with tmp as (with tmp1 as (select * from bison_t1) select * from tmp1) select * from tmp order by a;

A           
------------
1           
2           
3           
5           
            

5 rows fetched.

SQL> 
SQL> with tmp as (with tmp1 as (select * from bison_t1) select * from tmp1) select * from tmp limit 2;

A           
------------
2           
1           

2 rows fetched.

SQL> 
SQL> -- 目标表：现有员工信息
SQL> drop table if exists employees;

Succeed.

SQL> CREATE TABLE employees (
  2     emp_id NUMBER PRIMARY KEY,
  3     name VARCHAR2(20),
  4     salary NUMBER,
  5     last_update DATE
  6 );

Succeed.

SQL> INSERT INTO employees VALUES (1, '张三', 5000, SYSDATE-30);

OG-00601, [1:50]Sql syntax error: syntax error
SQL> INSERT INTO employees VALUES (2, '李四', 6000, SYSDATE-30);

OG-00601, [1:50]Sql syntax error: syntax error
SQL> 
SQL> -- 来源表：本次要同步的更新数据
SQL> drop table if exists salary_updates;

Succeed.

SQL> CREATE TABLE salary_updates (
  2     emp_id NUMBER PRIMARY KEY,
  3     new_salary NUMBER,
  4     update_date DATE
  5 );

Succeed.

SQL> INSERT INTO salary_updates VALUES (1, 5500, SYSDATE); -- 张三加薪

OG-00601, [1:45]Sql syntax error: syntax error
SQL> INSERT INTO salary_updates VALUES (3, 7000, SYSDATE); -- 新员工王五

OG-00601, [1:45]Sql syntax error: syntax error
SQL> 
SQL> MERGE INTO employees e
  2 USING salary_updates s
  3 ON (e.emp_id = s.emp_id)
  4 WHEN MATCHED THEN
  5     UPDATE SET 
  6         e.salary = s.new_salary,
  7         e.last_update = s.update_date
  8     WHERE s.new_salary > e.salary
  9 WHEN NOT MATCHED THEN INSERT (e.emp_id, e.name, e.salary, e.last_update)
 10     VALUES (s.emp_id, '新员工', s.new_salary, s.update_date);

0 rows affected.

SQL> 
SQL> MERGE INTO employees e
  2 USING salary_updates s
  3 ON (e.emp_id = s.emp_id)
  4 WHEN NOT MATCHED THEN INSERT (e.emp_id, e.name, e.salary, e.last_update)
  5     VALUES (s.emp_id, '新员工', s.new_salary, s.update_date);

0 rows affected.

SQL> 
SQL> MERGE INTO employees e
  2 USING salary_updates s
  3 ON (e.emp_id = s.emp_id)
  4 WHEN MATCHED THEN
  5     UPDATE SET 
  6         e.salary = s.new_salary,
  7         e.last_update = s.update_date
  8     WHERE s.new_salary > e.salary;

0 rows affected.

SQL> 
SQL> MERGE INTO employees e
  2 USING salary_updates s
  3 ON (e.emp_id = s.emp_id)
  4 WHEN NOT MATCHED THEN INSERT (e.emp_id, e.name, e.salary, e.last_update)
  5     VALUES (s.emp_id, '新员工', s.new_salary, s.update_date)
  6 WHEN MATCHED THEN
  7     UPDATE SET 
  8         e.salary = s.new_salary,
  9         e.last_update = s.update_date
 10     WHERE s.new_salary > e.salary;

0 rows affected.

SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b int);

Succeed.

SQL> replace into bison_t1 (a, b) values (1,1), (2,2);

2 rows affected.

SQL> replace into bison_t1 (a, b) select 1,2;

1 rows affected.

SQL> replace into bison_t1 values (1,1), (2,2);

2 rows affected.

SQL> replace into bison_t1 select 1,2;

1 rows affected.

SQL> replace into bison_t1 set a = 5, b = 5;

1 rows affected.

SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> drop table if exists bison_t1;

Succeed.

SQL> 
SQL> create temporary table #temp_bison_t1 (a int);

OG-00601, Sql syntax error: parameter LOCAL_TEMPORARY_TABLE_ENABLED is false, can't create local temporary table
SQL> drop table #temp_bison_t1;

OG-00843, [1:26]The table or view SYS.#TEMP_BISON_T1 does not exist.
SQL> drop temporary table #temp_bison_t1;

OG-00843, [1:36]The table or view SYS.#TEMP_BISON_T1 does not exist.
SQL> 
SQL> drop table if exists bison_t1;

Succeed.

SQL> create table bison_t1 (a int);

Succeed.

SQL> drop view if exists v1;

Succeed.

SQL> create view v1 as select * from bison_t1;

Succeed.

SQL> drop table bison_t1;

Succeed.

SQL> drop table bison_t1 cascade;

OG-00843, [1:28]The table or view SYS.BISON_T1 does not exist.
SQL> drop table bison_t1 cascade constraints;

OG-00843, [1:40]The table or view SYS.BISON_T1 does not exist.
SQL> 
SQL> drop table if exists bison_t1;

Succeed.

SQL> create table bison_t1 (a int);

Succeed.

SQL> drop table bison_t1 purge;

Succeed.

SQL> 
SQL> drop table if exists bison_t1;

Succeed.

SQL> create table bison_t1 (a int);

Succeed.

SQL> drop table sys.bison_t1;

Succeed.

SQL> 
SQL> drop table if exists bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b int);

Succeed.

SQL> create index bison_t1_idx on bison_t1 (a);

Succeed.

SQL> drop index sys.bison_t1_idx on bison_t1;

Succeed.

SQL> drop index if exists sys.bison_t1_idx on bison_t1;

Succeed.

SQL> 
SQL> create sequence bison_t1;

Succeed.

SQL> drop sequence if exists bison_t1;

Succeed.

SQL> 
SQL> drop tablespace bison_t1;

OG-00780, The tablespace  does not exist.
SQL> drop tablespace bison_t1 including contents cascade;

OG-00780, The tablespace  does not exist.
SQL> drop tablespace bison_t1 including contents and datafiles cascade;

OG-00780, The tablespace  does not exist.
SQL> drop tablespace bison_t1 including contents keep datafiles;

OG-00780, The tablespace  does not exist.
SQL> 
SQL> drop user if exists xbin;

OG-00781, The user XBIN does not exist.
SQL> drop user if exists xbin cascade;

OG-00781, The user XBIN does not exist.
SQL> 
SQL> drop public synonym public.syn1;

OG-00724, Synonym PUBLIC.SYN1 does not exist
SQL> drop public synonym sys.syn1 force;

OG-00601, [1:30]Sql syntax error: owner of object should be public
SQL> drop synonym public.syn1;

OG-00724, Synonym PUBLIC.SYN1 does not exist
SQL> drop public synonym "PUBLIC".syn1;

OG-00724, Synonym PUBLIC.SYN1 does not exist
SQL> drop synonym sys.syn1 force;

OG-00724, Synonym SYS.SYN1 does not exist
SQL> 
SQL> drop role xbin;

OG-00783, The role XBIN does not exist.
SQL> 
SQL> drop profile default cascade;

OG-00601, [1:22]Sql syntax error: cannot drop PUBLIC_DEFAULT profile
SQL> drop profile xxx cascade;

OG-00785, Profile XXX does not exist
SQL> 
SQL> drop directory xxx;

OG-00708, The object directory XXX does not exist
SQL> 
SQL> drop function fun1;

OG-00828, object SYS.FUN1 does not exist
SQL> drop function if exists fun1;

Succeed.

SQL> drop function if exists sys.fun1;

Succeed.

SQL> drop function if exists fun1(int); --error

OG-00601, [1:29]Sql syntax error: syntax error
SQL> 
SQL> drop procedure if exists pro1;

Succeed.

SQL> drop procedure if exists sys.pro1;

Succeed.

SQL> 
SQL> drop trigger if exists tri1;

Succeed.

SQL> 
SQL> drop package if exists pkg1;

Succeed.

SQL> drop package body if exists pkg1;

Succeed.

SQL> 
SQL> drop type if exists typ1 force;

Succeed.

SQL> drop type body if exists typ1 force;

OG-00958, Unsupported feature
SQL> 
SQL> drop library lib1;

OG-00828, library SYS.LIB1 does not exist
SQL> 
SQL> 
SQL> create table bison_t1 (a int, b int);

OG-01301, SYS.BISON_T1 already exists
SQL> insert into bison_t1 values (1,1);

1 rows affected.

SQL> truncate table bison_t1;

Succeed.

SQL> truncate table bison_t1 purge;

Succeed.

SQL> truncate table bison_t1 purge drop storage;

Succeed.

SQL> truncate table bison_t1 purge drop storage drop storage;

Succeed.

SQL> truncate table bison_t1 purge reuse storage;

Succeed.

SQL> truncate table bison_t1 purge reuse storage drop storage;

OG-00601, [1:50]Sql syntax error: unexpected text conflict
SQL> 
SQL> flashback table bison_t1 to scn '10';

OG-00732, The table definition of SYS.BISON_T1 has been changed.
SQL> flashback table bison_t1 to scn 10;

OG-00732, The table definition of SYS.BISON_T1 has been changed.
SQL> flashback table bison_t1 to TIMESTAMP to_timestamp('2025-12-15 10:00:00');

OG-00806, Scn too old and no snapshot found based on specified time
SQL> 
SQL> flashback table bison_t1 to before drop rename to tbison_t2;

OG-00829, Recyclebin object SYS.BISON_T1 does not exist
SQL> flashback table bison_t1 to before drop;

OG-00829, Recyclebin object SYS.BISON_T1 does not exist
SQL> flashback table bison_t1 to before truncate force;

OG-00829, Recyclebin object SYS.BISON_T1 does not exist
SQL> flashback table bison_t1 to before truncate;

OG-00829, Recyclebin object SYS.BISON_T1 does not exist
SQL> 
SQL> flashback table bison_t1 partition p1 to before truncate;

OG-00130, Operation flashback table partition is not supported on BISON_T1
SQL> 
SQL> flashback table bison_t1 partition p1 to scn '10'; --error

OG-00601, [1:42]Sql syntax error: syntax error
SQL> flashback table bison_t1 partition p1 to before drop rename to tbison_t2; --error

OG-00601, [1:49]Sql syntax error: syntax error
SQL> 
SQL> comment on table bison_t1 is 'test comment table';

Succeed.

SQL> comment on column bison_t1.a is 'test comment column';

Succeed.

SQL> comment on table bison_t1 is 'xx''a';

Succeed.

SQL> 
SQL> comment on column bison_t1.a is '';

Succeed.

SQL> comment on column bison_t1.a is NULL; --error

OG-00601, [1:33]Sql syntax error: syntax error
SQL> 
SQL> drop table bison_t1;

Succeed.

SQL> create table bison_t1 (a int, b int);

Succeed.

SQL> create index bison_t1_idx on bison_t1(a);

Succeed.

SQL> 
SQL> analyze table bison_t1 compute statistics;

Succeed.

SQL> analyze table bison_t1 compute statistics for report;

Succeed.

SQL> analyze table bison_t1 compute statistics for report sample 60;

Succeed.

SQL> 
SQL> analyze index bison_t1_idx on bison_t1 compute statistics;

Succeed.

SQL> analyze index bison_t1_idx on bison_t1 estimate statistics 10;

Succeed.

SQL> analyze index bison_t1_idx on bison_t1 compute statistics for report; --error

OG-00601, [1:59]Sql syntax error: syntax error
SQL> 
SQL> create database clustered db1 user SYS IDENTIFIED by 'Huawei@123' instance node 0 nologging undo tablespace tempfile 'a' size 10M undo tablespace datafile 'b' size 10M temporary TABLESPACE TEMPFILE 'c' size 10M logfile ('logfile1' size 10M blocksize 512, 'logfile2' size 10M blocksize 512, 'logfile3' size 10M blocksize 512) controlfile ('d', 'e') character set uft8 archivelog;

OG-00738, [1:378]The database is already in the MOUNT state
SQL> 
SQL> create database clustered db1 user SYS IDENTIFIED by 'Huawei@123' instance node 0 nologging undo tablespace tempfile 'a' size 10M undo tablespace datafile 'b' size 10M, 'bb' size 10M reuse autoextend off temporary TABLESPACE TEMPFILE 'c' size 10M logfile ('logfile1' size 10M blocksize 512, 'logfile2' size 10M blocksize 512, 'logfile3' size 10M blocksize 512) controlfile ('d', 'e') character set uft8 archivelog;

OG-00738, [1:414]The database is already in the MOUNT state
SQL> 
SQL> create database clustered db1 user SYS IDENTIFIED by 'Huawei@123' instance node 0 nologging undo tablespace tempfile 'a' size 10M undo tablespace datafile 'b' size 10M, 'bb' size 10M reuse autoextend on next 5M maxsize 100M temporary TABLESPACE TEMPFILE 'c' size 10M logfile ('logfile1' size 10M blocksize 512, 'logfile2' size 10M blocksize 512, 'logfile3' size 10M blocksize 512) controlfile ('d', 'e') character set uft8 archivelog;

OG-00738, [1:434]The database is already in the MOUNT state
SQL> 
SQL> create database clustered db1 user SYS IDENTIFIED by 'Huawei@123' nologging undo tablespace tempfile 'a' size 10M system tablespace datafile 'st' size 128.6M sysaux tablespace datafile 'ast' size 128M default tablespace datafile 'ast' size 1M instance node 0 nologging undo tablespace tempfile 'a' size 10M undo tablespace datafile 'b' size 10M temporary TABLESPACE TEMPFILE 'c' size 10M logfile ('logfile1' size 10M blocksize 512, 'logfile2' size 10M blocksize 512, 'logfile3' size 10M blocksize 512) controlfile ('d', 'e') character set uft8 archivelog MAXINSTANCES 5;

OG-00601, [1:152]Sql syntax error: syntax error
SQL> 
SQL> create database clustered db1 user SYS IDENTIFIED by 'Huawei@123' instance node 0 nologging undo tablespace tempfile 'a' size 10M undo tablespace datafile 'b' size 10M temporary TABLESPACE TEMPFILE 'c' size 10M logfile ('logfile1' size 10M blocksize 512, 'logfile2' size 10M blocksize 512, 'logfile3' size 10M blocksize 512) node 0 nologging undo tablespace tempfile 'aa' size 10M undo tablespace datafile 'bb' size 10M temporary TABLESPACE TEMPFILE 'cc' size 10M logfile ('logfile11' size 10M blocksize 512, 'logfile21' size 10M blocksize 512, 'logfile31' size 10M blocksize 512) controlfile ('d', 'e') character set uft8 noarchivelog;

OG-00601, [1:636]Sql syntax error: parse create database failed
SQL> 
SQL> create database db1 user xbin IDENTIFIED by 'Huawei@123'; --error

OG-00601, [1:17]Sql syntax error: syntax error
SQL> 
SQL> ------------------------------------
SQL> --function/expression test
SQL> --will create two table, one for use_bison_parser is on while anotner is off
SQL> --test the result by join two table
SQL> --func_res_test_bison: use_bison_parser is on
SQL> --func_res_test_bison_off: use_bison_parser is off
SQL> ------------------------------------
SQL> CREATE TABLE json_col_test(id serial primary key, json_col CLOB);

Succeed.

SQL> INSERT INTO json_col_test(json_col) VALUES ('{"name":"张三", "age":25, "address":{"city":"北京"}}'); -- 合法 JSON

1 rows affected.

SQL> INSERT INTO json_col_test(json_col) VALUES ('{"name":"李四", "age":30}'); -- 合法 JSON（无 address 路径）

1 rows affected.

SQL> INSERT INTO json_col_test(json_col) VALUES ('{name:"王五", age:35}'); -- 非法 JSON（键未加双引号）

1 rows affected.

SQL> INSERT INTO json_col_test(json_col) VALUES ('不是 JSON 数据'); -- 完全非法的非 JSON 字符串

1 rows affected.

SQL> INSERT INTO json_col_test(json_col) VALUES (NULL); -- 空值

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create table jb_merpatch_tbl_bison(id serial primary key, a jsonb);

Succeed.

SQL> insert into jb_merpatch_tbl_bison(a) values('{"addres":"CHN", "id":"55185651515", "name":"zzzzzzzzzzzzzzzzzzzzzzzzzzzz", "age":4444444444444444444444444, "hobby":[1,2,34,5]}');

1 rows affected.

SQL> insert into jb_merpatch_tbl_bison(a) values('[1,2,3,4,5,6]');

1 rows affected.

SQL> insert into jb_merpatch_tbl_bison(a) values('{"AAA":{"BBB":{"CCC":"XXXXX"}}}');

1 rows affected.

SQL> insert into jb_merpatch_tbl_bison(a) values('[1, 2, {"AAA":{"BBB":{"CCC":"XXXXX"}}}]');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create table func_res_test_bison(id serial primary key, result varchar(1000));

Succeed.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[0,1,2,3,4]', '$[3]' WITH WRAPPER));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[*]' WITH CONDITIONAL WRAPPER));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]'));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty on error));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty on empty));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty ARRAY on empty));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty ARRAY on error));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty OBJECT on empty));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty OBJECT on error));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_MERGEPATCH('{"id":1,"first_name":"Iron","last_name":"Man"}', '{"last_name":"banana"}'));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_MERGEPATCH('{"id":1,"first_name":"Iron","last_name":"Man"}', '{}' RETURNING VARCHAR2(10) error on error));

OG-02502, Output value too large
SQL> insert into func_res_test_bison(result) values (JSON_MERGEPATCH('{"id":1,"first_name":"Iron","last_name":"Man"}', '{}' RETURNING VARCHAR2(10) null on error));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_VALUE('{"x":1, "y":2}', '$.y'));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_VALUE('[1,2]', '$[2]' NULL ON ERROR));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_VALUE('[1,2]', '$[2]' NULL ON empty));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (JSON_VALUE('[1,2]', '$[2]' error ON empty));

OG-02506, JSON_VALUE evaluated to no value
SQL> insert into func_res_test_bison(result) values (JSON_VALUE('[1,2]', '$[2]' error ON ERROR));

OG-02506, JSON_VALUE evaluated to no value
SQL> 
SQL> insert into func_res_test_bison(result) select JSON_EXISTS(json_col, '$.address.city') from json_col_test order by id;

5 rows affected.

SQL> insert into func_res_test_bison(result) select JSON_EXISTS(json_col, '$.address.city' true on error) from json_col_test order by id;

5 rows affected.

SQL> insert into func_res_test_bison(result) select JSON_EXISTS(json_col, '$.address.city' false on error) from json_col_test order by id;

5 rows affected.

SQL> insert into func_res_test_bison(result) select JSON_EXISTS(json_col, '$.address.city' error on error) from json_col_test order by id;

OG-02504, JSON syntax error, " expected but n found
SQL> 
SQL> insert into func_res_test_bison(result) values (json_set('{"name":"andy", "age":18, "addr":"China", "ho":[1,2,3,4]}', '$.name'));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (json_set('{"name":"andy", "age":18, "addr":"China", "ho":[1,2,3,4]}', '$'));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (json_set('{"name":"andy", "age":18, "addr":"China", "ho":[1,2,3,4]}', '$.name', '{"bbb":66, "aaa":54}'));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (json_set('[[1,2,3,4]]', '$[0][6]', '{"aaa":54}', true returning clob error on error));

1 rows affected.

SQL> insert into func_res_test_bison(result) values (json_set('[[1,2,3,4]]', '$[0][6]', '{"aaa":54}', true returning clob));

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison(result) select jsonb_mergepatch(a, '{"name":"andy", "age":12}') from jb_merpatch_tbl_bison where id = 1;

1 rows affected.

SQL> insert into func_res_test_bison(result) select JSONB_QUERY(a, '$[*]' WITH CONDITIONAL WRAPPER) from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> insert into func_res_test_bison(result) select JSONB_VALUE(a, '$.addres') from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> insert into func_res_test_bison(result) select JSONB_EXISTS(a, '$.id') from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> insert into func_res_test_bison(result) select JSONB_SET(a, '$.id') from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> 
SQL> insert into func_res_test_bison(result) SELECT JSON_OBJECT('name' is 'Tim', 'age' is 20);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT JSON_OBJECT(KEY 'name' is 'Tim', KEY 'age' is 20);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT JSON_OBJECT(KEY 'name' : 'Tim', KEY 'age' : 20); -- error

OG-00601, [1:71]Sql syntax error: syntax error
SQL> insert into func_res_test_bison(result) SELECT JSON_ARRAY(1,2,3,4);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT JSON_ARRAY('[1,2,3]' FORMAT JSON, '{"x":1}' FORMAT JSON);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT JSON_ARRAY('[1,2,3]' , '{"x":1}' FORMAT JSON);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT JSON_ARRAY('[1,2,3]' FORMAT JSON, '{"x":1}');

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison(result)  select interval '22' year;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '2022' year; --error

OG-00674, [1:69]YEAR field exceeds the specified precision (2)
SQL> insert into func_res_test_bison(result)  select interval '2022' year(4);

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '22' year to year;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '2022' year to year; --error

OG-00674, [1:73]YEAR field exceeds the specified precision (2)
SQL> insert into func_res_test_bison(result)  select interval '2022' year(4) to year;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '22' year to MONTH; --error

OG-00673, [1:71]Invalid interval text -- format error
SQL> insert into func_res_test_bison(result)  select interval '2022-11' year to MONTH; --error

OG-00674, [1:76]YEAR field exceeds the specified precision (2)
SQL> insert into func_res_test_bison(result)  select interval '2022-11' year(4) to MONTH;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '0 0:0:1' day to second;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '0 0:0:1' day(5) to second(2);

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '11 22:05' day to minute;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '100 10' day to hour; --error

OG-00674, [1:74]DAY field exceeds the specified precision (2)
SQL> insert into func_res_test_bison(result)  select interval '100 10' day(3) to hour;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '1' second(5,1);

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '8' month;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '8' day;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '8' hour;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '8' minute;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '09:30' hour to day; --error

OG-00601, [1:74]Sql syntax error: -- invalid field name
SQL> insert into func_res_test_bison(result)  select interval '09:30' minute to hour; --error

OG-00601, [1:76]Sql syntax error: -- invalid field name
SQL> insert into func_res_test_bison(result)  select interval '09:30' hour to minute;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '09:30:1.11' hour to second;

1 rows affected.

SQL> insert into func_res_test_bison(result)  select interval '09:30' minute to second;

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison(result) select 0x573456;

1 rows affected.

SQL> insert into func_res_test_bison(result) select X'573456';

1 rows affected.

SQL> insert into func_res_test_bison(result) select X'5734567'; --error

OG-00105, [1:48]Invalid format of hex
SQL> insert into func_res_test_bison(result) select x'573456'; --error

OG-00601, [1:49]Sql syntax error: syntax error
SQL> 
SQL> insert into func_res_test_bison(result) select 1::int;

1 rows affected.

SQL> insert into func_res_test_bison(result) select -(-4);

1 rows affected.

SQL> insert into func_res_test_bison(result) select -4;

1 rows affected.

SQL> insert into func_res_test_bison(result) select +5;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 5423237233838653440 << 20;

1 rows affected.

SQL> insert into func_res_test_bison(result) select -5423237233838653440 >> 32;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 542323723383865345324532452343440 >> 32;

OG-00659, [1:48]BIGINT out of range
SQL> insert into func_res_test_bison(result) select 5423237233838653440 >> 32;

1 rows affected.

SQL> insert into func_res_test_bison(result) select -542323723334534534534535838653440 >> 32;

OG-00659, [1:48]BIGINT out of range
SQL> insert into func_res_test_bison(result) select -5423237233838653440 >> 30;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 838653440 >> 32234444444444444444444444444444444;

OG-00659, [1:48]BIGINT out of range
SQL> insert into func_res_test_bison(result) select 2147483648 + 1;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 120::decimal(3, -1);

1 rows affected.

SQL> insert into func_res_test_bison(result) select 120::date;

OG-00606, [1:48]Inconsistent datatypes, expected DATE - got BINARY_INTEGER
SQL> insert into func_res_test_bison(result) select case when 1 = 0 then 1 - 1 else 2.123 end from sys_dummy;

1 rows affected.

SQL> insert into func_res_test_bison(result) select convert((case(cast(1 as int) & 2) when 0 then 1 else 2 end) / 2, int);

1 rows affected.

SQL> insert into func_res_test_bison(result) select convert((case(cast(1 as int) & 1) when (cast(1 as int) & 1) then (case (1) when (1) then (1) else (0) end) else (cast (3 as int) & 3) end) / 2, int);

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison(result) select 1^2|3;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 1&2<<3;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 1&2>>3;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 1<<3||4;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 1>>3||4;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 4||5+6;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 4||6-1;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 4+5*6;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 4+5/6;

1 rows affected.

SQL> insert into func_res_test_bison(result) select 4+5%6;

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison(result) SELECT SUBSTR('Quadratically',5,6);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT SUBSTR('Quadratically' FROM 5 FOR 6);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT SUBSTRING('Quadratically',5,6);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT SUBSTRING('Quadratically' FROM 5 FOR 6);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT EXTRACT (MONTH from '2018-10-04');

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT CONVERT('2018-06-28 13:14:15', timestamp);

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT TRIM(LEADING '1' FROM '123sfd111');

1 rows affected.

SQL> insert into func_res_test_bison(result) SELECT TRIM( '123sfd111','1');

1 rows affected.

SQL> 
SQL> select * from func_res_test_bison order by id;

ID                   RESULT                                                          
-------------------- ----------------------------------------------------------------
1                    [3]                                                             
2                    [{"a":100},{"b":200},{"c":300}]                                 
3                                                                                    
4                    []                                                              
5                    []                                                              
6                    []                                                              
7                    []                                                              
8                    {}                                                              
9                    {}                                                              
10                   {"id":1,"first_name":"Iron","last_name":"banana"}               
12                                                                                   
13                   2                                                               
14                                                                                   
15                                                                                   
18                   TRUE                                                            
19                   FALSE                                                           
20                   FALSE                                                           
21                   FALSE                                                           
22                                                                                   
23                   TRUE                                                            
24                   FALSE                                                           
25                   TRUE                                                            
26                   TRUE                                                            
27                                                                                   
28                   TRUE                                                            
29                   FALSE                                                           
30                   FALSE                                                           
31                   FALSE                                                           
32                                                                                   
33                   {"age":18,"addr":"China","ho":[1,2,3,4]}                        
34                                                                                   
35                   {"name":{"bbb":66,"aaa":54},"age":18,"addr":"China","ho":[1,2,3,4]}
36                   [[1,2,3,4,{"aaa":54}]]                                          
37                   [[1,2,3,4,{"aaa":54}]]                                          
38                   {"addres":"CHN","age":12,"hobby":[1,2,34,5],"id":"55185651515","name":"andy"}
39                   {"addres":"CHN","age":4444444444444444444444444,"hobby":[1,2,34,5],"id":"55185651515","name":"zzzzzzzzzzzzzzzzzzzzzzzzzzzz"}
40                   [1,2,3,4,5,6]                                                   
41                   {"AAA":{"BBB":{"CCC":"XXXXX"}}}                                 
42                   [1,2,{"AAA":{"BBB":{"CCC":"XXXXX"}}}]                           
43                   CHN                                                             
44                                                                                   
45                                                                                   
46                                                                                   
47                   TRUE                                                            
48                   FALSE                                                           
49                   FALSE                                                           
50                   FALSE                                                           
51                   {"addres":"CHN","age":4444444444444444444444444,"hobby":[1,2,34,5],"name":"zzzzzzzzzzzzzzzzzzzzzzzzzzzz"}
52                   [1,2,3,4,5,6]                                                   
53                   {"AAA":{"BBB":{"CCC":"XXXXX"}}}                                 
54                   [1,2,{"AAA":{"BBB":{"CCC":"XXXXX"}}}]                           
55                   {"name":"Tim","age":20}                                         
56                   {"name":"Tim","age":20}                                         
57                   [1,2,3,4]                                                       
58                   [[1,2,3],{"x":1}]                                               
59                   ["[1,2,3]",{"x":1}]                                             
60                   [[1,2,3],"{\"x\":1}"]                                           
61                   +22-00                                                          
62                   +2022-00                                                        
63                   +22-00                                                          
64                   +2022-00                                                        
65                   +2022-11                                                        
66                   +00 00:00:01.000000                                             
67                   +00 00:00:01.000000                                             
68                   +11 22:05:00.000000                                             
69                   +100 10:00:00.000000                                            
70                   +00 00:00:01.000000                                             
71                   +00-08                                                          
72                   +08 00:00:00.000000                                             
73                   +00 08:00:00.000000                                             
74                   +00 00:08:00.000000                                             
75                   +00 09:30:00.000000                                             
76                   +00 09:30:01.110000                                             
77                   +00 00:09:30.000000                                             
78                   W4V                                                             
79                   W4V                                                             
80                   1                                                               
81                   4                                                               
82                   -4                                                              
83                   5                                                               
84                   6376386787845079040                                             
85                   -1262695816                                                     
86                   1262695815                                                      
87                   -5050783264                                                     
88                   2147483649                                                      
89                   120                                                             
90                   2.123                                                           
91                   1                                                               
92                   1                                                               
93                   3                                                               
94                   0                                                               
95                   0                                                               
96                   17179869184                                                     
97                   0                                                               
98                   51                                                              
99                   45                                                              
100                  34                                                              
101                  4.83333333333333                                                
102                  9                                                               
103                  ratica                                                          
104                  ratica                                                          
105                  ratica                                                          
106                  ratica                                                          
107                  10                                                              
108                  2018-06-28 13:14:15.000000                                      
109                  23sfd111                                                        
110                  23sfd                                                           

107 rows fetched.

SQL> 
SQL> ------------------------------------
SQL> --same test case for func_res_test_bison_off
SQL> alter system set use_bison_parser = false;

Succeed.

SQL> 
SQL> create table func_res_test_bison_off(id serial primary key, result varchar(1000));

Succeed.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[0,1,2,3,4]', '$[3]' WITH WRAPPER));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[*]' WITH CONDITIONAL WRAPPER));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]'));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty on error));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty on empty));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty ARRAY on empty));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty ARRAY on error));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty OBJECT on empty));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_QUERY('[{"a":100},{"b":200},{"c":300}]', '$[3]' empty OBJECT on error));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_MERGEPATCH('{"id":1,"first_name":"Iron","last_name":"Man"}', '{"last_name":"banana"}'));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_MERGEPATCH('{"id":1,"first_name":"Iron","last_name":"Man"}', '{}' RETURNING VARCHAR2(10) error on error));

OG-02502, Output value too large
SQL> insert into func_res_test_bison_off(result) values (JSON_MERGEPATCH('{"id":1,"first_name":"Iron","last_name":"Man"}', '{}' RETURNING VARCHAR2(10) null on error));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_VALUE('{"x":1, "y":2}', '$.y'));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_VALUE('[1,2]', '$[2]' NULL ON ERROR));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_VALUE('[1,2]', '$[2]' NULL ON empty));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (JSON_VALUE('[1,2]', '$[2]' error ON empty));

OG-02506, JSON_VALUE evaluated to no value
SQL> insert into func_res_test_bison_off(result) values (JSON_VALUE('[1,2]', '$[2]' error ON ERROR));

OG-02506, JSON_VALUE evaluated to no value
SQL> 
SQL> insert into func_res_test_bison_off(result) select JSON_EXISTS(json_col, '$.address.city') from json_col_test order by id;

5 rows affected.

SQL> insert into func_res_test_bison_off(result) select JSON_EXISTS(json_col, '$.address.city' true on error) from json_col_test order by id;

5 rows affected.

SQL> insert into func_res_test_bison_off(result) select JSON_EXISTS(json_col, '$.address.city' false on error) from json_col_test order by id;

5 rows affected.

SQL> insert into func_res_test_bison_off(result) select JSON_EXISTS(json_col, '$.address.city' error on error) from json_col_test order by id;

OG-02504, [1:66]JSON syntax error, " expected but n found
SQL> 
SQL> insert into func_res_test_bison_off(result) values (json_set('{"name":"andy", "age":18, "addr":"China", "ho":[1,2,3,4]}', '$.name'));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (json_set('{"name":"andy", "age":18, "addr":"China", "ho":[1,2,3,4]}', '$'));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (json_set('{"name":"andy", "age":18, "addr":"China", "ho":[1,2,3,4]}', '$.name', '{"bbb":66, "aaa":54}'));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (json_set('[[1,2,3,4]]', '$[0][6]', '{"aaa":54}', true returning clob error on error));

1 rows affected.

SQL> insert into func_res_test_bison_off(result) values (json_set('[[1,2,3,4]]', '$[0][6]', '{"aaa":54}', true returning clob));

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison_off(result) select jsonb_mergepatch(a, '{"name":"andy", "age":12}') from jb_merpatch_tbl_bison where id = 1;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select JSONB_QUERY(a, '$[*]' WITH CONDITIONAL WRAPPER) from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> insert into func_res_test_bison_off(result) select JSONB_VALUE(a, '$.addres') from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> insert into func_res_test_bison_off(result) select JSONB_EXISTS(a, '$.id') from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> insert into func_res_test_bison_off(result) select JSONB_SET(a, '$.id') from jb_merpatch_tbl_bison order by id;

4 rows affected.

SQL> 
SQL> insert into func_res_test_bison_off(result) SELECT JSON_OBJECT('name' is 'Tim', 'age' is 20);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT JSON_OBJECT(KEY 'name' is 'Tim', KEY 'age' is 20);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT JSON_OBJECT(KEY 'name' : 'Tim', KEY 'age' : 20); -- error

OG-00601, [1:75]Sql syntax error: the word ":" is not correct
SQL> insert into func_res_test_bison_off(result) SELECT JSON_ARRAY(1,2,3,4);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT JSON_ARRAY('[1,2,3]' FORMAT JSON, '{"x":1}' FORMAT JSON);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT JSON_ARRAY('[1,2,3]' , '{"x":1}' FORMAT JSON);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT JSON_ARRAY('[1,2,3]' FORMAT JSON, '{"x":1}');

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison_off(result)  select interval '22' year;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '2022' year; --error

OG-00674, YEAR field exceeds the specified precision (2)
SQL> insert into func_res_test_bison_off(result)  select interval '2022' year(4);

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '22' year to year;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '2022' year to year; --error

OG-00674, YEAR field exceeds the specified precision (2)
SQL> insert into func_res_test_bison_off(result)  select interval '2022' year(4) to year;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '22' year to MONTH; --error

OG-00673, Invalid interval text -- format error
SQL> insert into func_res_test_bison_off(result)  select interval '2022-11' year to MONTH; --error

OG-00674, YEAR field exceeds the specified precision (2)
SQL> insert into func_res_test_bison_off(result)  select interval '2022-11' year(4) to MONTH;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '0 0:0:1' day to second;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '0 0:0:1' day(5) to second(2);

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '11 22:05' day to minute;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '100 10' day to hour; --error

OG-00674, DAY field exceeds the specified precision (2)
SQL> insert into func_res_test_bison_off(result)  select interval '100 10' day(3) to hour;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '1' second(5,1);

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '8' month;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '8' day;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '8' hour;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '8' minute;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '09:30' hour to day; --error

OG-00673, [1:78]Invalid interval text -- invalid field name
SQL> insert into func_res_test_bison_off(result)  select interval '09:30' minute to hour; --error

OG-00673, [1:80]Invalid interval text -- invalid field name
SQL> insert into func_res_test_bison_off(result)  select interval '09:30' hour to minute;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '09:30:1.11' hour to second;

1 rows affected.

SQL> insert into func_res_test_bison_off(result)  select interval '09:30' minute to second;

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison_off(result) select 0x573456;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select X'573456';

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select X'5734567'; --error

OG-00105, Invalid format of hex
SQL> insert into func_res_test_bison_off(result) select x'573456'; --error

OG-00601, [1:53]Sql syntax error: FROM expected but '573456' found
SQL> 
SQL> insert into func_res_test_bison_off(result) select 1::int;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select -(-4);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select -4;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select +5;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 5423237233838653440 << 20;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select -5423237233838653440 >> 32;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 542323723383865345324532452343440 >> 32;

OG-00659, [1:86]BIGINT out of range
SQL> insert into func_res_test_bison_off(result) select 5423237233838653440 >> 32;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select -542323723334534534534535838653440 >> 32;

OG-00659, [1:87]BIGINT out of range
SQL> insert into func_res_test_bison_off(result) select -5423237233838653440 >> 30;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 838653440 >> 32234444444444444444444444444444444;

OG-00659, [1:62]BIGINT out of range
SQL> insert into func_res_test_bison_off(result) select 2147483648 + 1;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 120::decimal(3, -1);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 120::date;

OG-00606, [1:52]Inconsistent datatypes, expected DATE - got BINARY_INTEGER
SQL> insert into func_res_test_bison_off(result) select case when 1 = 0 then 1 - 1 else 2.123 end from sys_dummy;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select convert((case(cast(1 as int) & 2) when 0 then 1 else 2 end) / 2, int);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select convert((case(cast(1 as int) & 1) when (cast(1 as int) & 1) then (case (1) when (1) then (1) else (0) end) else (cast (3 as int) & 3) end) / 2, int);

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison_off(result) select 1^2|3;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 1&2<<3;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 1&2>>3;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 1<<3||4;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 1>>3||4;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 4||5+6;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 4||6-1;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 4+5*6;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 4+5/6;

1 rows affected.

SQL> insert into func_res_test_bison_off(result) select 4+5%6;

1 rows affected.

SQL> 
SQL> insert into func_res_test_bison_off(result) SELECT SUBSTR('Quadratically',5,6);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT SUBSTR('Quadratically' FROM 5 FOR 6);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT SUBSTRING('Quadratically',5,6);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT SUBSTRING('Quadratically' FROM 5 FOR 6);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT EXTRACT (MONTH from '2018-10-04');

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT CONVERT('2018-06-28 13:14:15', timestamp);

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT TRIM(LEADING '1' FROM '123sfd111');

1 rows affected.

SQL> insert into func_res_test_bison_off(result) SELECT TRIM( '123sfd111','1');

1 rows affected.

SQL> 
SQL> -- should be 0, no not matched
SQL> select * from func_res_test_bison left join func_res_test_bison_off
  2 on func_res_test_bison.id = func_res_test_bison_off.id
  3 where func_res_test_bison.result != func_res_test_bison_off.result ;

ID                   RESULT                                                           ID                   RESULT                                                          
-------------------- ---------------------------------------------------------------- -------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> 
SQL> alter system set use_bison_parser = true;

Succeed.

SQL> 
SQL> drop table jb_merpatch_tbl_bison;

Succeed.

SQL> drop table json_col_test;

Succeed.

SQL> drop table func_res_test_bison;

Succeed.

SQL> drop table func_res_test_bison_off;

Succeed.

SQL> ------------------------------------
SQL> --function/expression test end
SQL> ------------------------------------
SQL> 
SQL> --if/lnnvl/group_concat/listagg/count over
SQL> CREATE TABLE  test_func_2
  2 (
  3   staff_ID       NUMBER(6) not null,
  4   NAME           VARCHAR2(20),
  5   EMAIL          VARCHAR2(25),
  6   PHONE_NUMBER   VARCHAR2(20),
  7   HIRE_DATE      DATE,
  8   employment_ID  VARCHAR2(10),
  9   SALARY         NUMBER(8,2),
 10   MANAGER_ID     NUMBER(6),
 11   section_ID     NUMBER(4)
 12 );

Succeed.

SQL> INSERT INTO test_func_2
  2 values (111, '张三', 'zhangsan@126.com', '13312345678', to_date('11-11-1999', 'dd-mm-yyyy'), 'SH_CLERK',  NULL, 124, 50);

1 rows affected.

SQL> INSERT INTO  test_func_2
  2 values (222, '李四', 'lisi@126.com', '13312345679', to_date('13-05-2000', 'dd-mm-yyyy'), 'SH_CLERK', 2600.00, 124, 50);

1 rows affected.

SQL> INSERT INTO  test_func_2 
  2 values (333, '王五', 'wangwu@126.com', '13312345680', to_date('01-11-1987', 'dd-mm-yyyy'), 'AD_ASST', 4400.00, 101, 10);

1 rows affected.

SQL> INSERT INTO  test_func_2 
  2 values (444, '赵二', 'zhaoer@126.com', '13312345681', to_date('13-12-1988', 'dd-mm-yyyy'), 'AD_ASST', 3900.00, 101, 10);

1 rows affected.

SQL> SELECT staff_ID, IF(SALARY < 4000, SALARY, 'secret') "SALARY" FROM test_func_2 WHERE staff_ID IS NOT NULL ORDER BY staff_ID;

STAFF_ID                                 SALARY                                                          
---------------------------------------- ----------------------------------------------------------------
111                                      secret                                                          
222                                      2600                                                            
333                                      secret                                                          
444                                      3900                                                            

4 rows fetched.

SQL> SELECT staff_ID,NAME,SALARY FROM test_func_2 WHERE LNNVL(SALARY<10000.00);

STAFF_ID                                 NAME                 SALARY                                  
---------------------------------------- -------------------- ----------------------------------------
111                                      张三                                                       

1 rows fetched.

SQL> SELECT staff_ID,GROUP_CONCAT(SALARY) FROM test_func_2 GROUP BY staff_ID;

STAFF_ID                                 GROUP_CONCAT(SALARY)                                            
---------------------------------------- ----------------------------------------------------------------
444                                      3900                                                            
111                                                                                                      
222                                      2600                                                            
333                                      4400                                                            

4 rows fetched.

SQL> select listagg(staff_ID) within group(order by staff_ID) over(partition by section_ID) from test_func_2;

LISTAGG(STAFF_ID) WITHIN GROUP(ORDER BY STAFF_ID) OVER(PARTITION
----------------------------------------------------------------
333444                                                          
333444                                                          
111222                                                          
111222                                                          

4 rows fetched.

SQL> select count(staff_ID) over(partition by section_ID order by staff_ID) from test_func_2;

COUNT(STAFF_ID) OVER(PARTITION BY SECTION_ID ORDER BY STAFF_ID)
---------------------------------------------------------------
1                                                              
2                                                              
1                                                              
2                                                              

4 rows fetched.

SQL> drop table test_func_2; 

Succeed.

SQL> 
SQL> --select (subquery)
SQL> select (select id from sys_tables);  -- error

OG-00915, [1:8]More than one return value of SELECT INTO, EXECUTE IMMEDIATE, or a cursor was assigned to a common variable.
SQL> select (select id from sys_tables limit 1);

ID          
------------
0           

1 rows fetched.

SQL> --array
SQL> select array[1,2];

ARRAY[1,2]                                                      
----------------------------------------------------------------
{1,2}                                                           

1 rows fetched.

SQL> select array[];

ARRAY[]                                                         
----------------------------------------------------------------
{}                                                              

1 rows fetched.

SQL> --join
SQL> create table t_first(a int, b int);

Succeed.

SQL> insert into t_first values(1,11),(2,22),(3,33);

3 rows affected.

SQL> create table t_second(c int, d int);

Succeed.

SQL> insert into t_second values(3,33);

1 rows affected.

SQL> select * from t_first,t_second where a(+)=c order by a;

A            B            C            D           
------------ ------------ ------------ ------------
3            33           3            33          

1 rows fetched.

SQL> select * from t_first,t_second where t_first.a(+)=c order by a;

A            B            C            D           
------------ ------------ ------------ ------------
3            33           3            33          

1 rows fetched.

SQL> select * from t_first,t_second where c=a(+) order by a;

A            B            C            D           
------------ ------------ ------------ ------------
3            33           3            33          

1 rows fetched.

SQL> select * from t_first,t_second where c=t_first.a(+) order by a;

A            B            C            D           
------------ ------------ ------------ ------------
3            33           3            33          

1 rows fetched.

SQL> select * from t_first,t_second where c(+)=a order by a;

A            B            C            D           
------------ ------------ ------------ ------------
1            11                                    
2            22                                    
3            33           3            33          

3 rows fetched.

SQL> select * from t_first,t_second where t_second.c(+)=a order by a;

A            B            C            D           
------------ ------------ ------------ ------------
1            11                                    
2            22                                    
3            33           3            33          

3 rows fetched.

SQL> select * from t_first,t_second where a=c(+) order by a;

A            B            C            D           
------------ ------------ ------------ ------------
1            11                                    
2            22                                    
3            33           3            33          

3 rows fetched.

SQL> select * from t_first,t_second where a=t_second.c(+) order by a;

A            B            C            D           
------------ ------------ ------------ ------------
1            11                                    
2            22                                    
3            33           3            33          

3 rows fetched.

SQL> select * from t_first,t_second where a(+)=c(+); --error

OG-00601, [1:43]Sql syntax error: invalid usage outer join symbol
SQL> select * from t_first,t_second where t_second.*(+)=a; --error

OG-00601, [1:38]Sql syntax error: unexpected '*'
SQL> drop table t_first;

Succeed.

SQL> drop table t_second;

Succeed.

SQL> --quote
SQL> select 1 as `1`; 

1           
------------
1           

1 rows fetched.

SQL> create table `t_lowercase`(`a_lowercase` int);

Succeed.

SQL> select count(*) from sys_tables where NAME='t_lowercase';

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> select sys_columns.name from sys_tables join sys_columns on sys_tables.id=sys_columns.TABLE# where sys_tables.NAME='t_lowercase';

OG-00601, [1:46]Sql syntax error: syntax error
SQL> drop table t_lowercase; --error

OG-00843, [1:23]The table or view SYS.T_LOWERCASE does not exist.
SQL> drop table `t_lowercase`;

Succeed.

SQL> 
SQL> alter system set use_bison_parser = false;

Succeed.

SQL> 


